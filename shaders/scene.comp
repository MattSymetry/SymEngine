vec2 calcObj (vec3 pos, NodeData node)
{
    vec3 objPos = node.transform[2].xyz;
    vec3 objRot = node.transform[1].xyz;
    vec3 objScale = node.transform[0].xyz;
    vec2 obj;

    if (node.obejctData[3].w == 0) { // Sphere
        obj = vec2( sdSphere(pos-objPos, node.obejctData[0].x), 1 );
    }
    else if (node.obejctData[3].w == 1) { // Box
        obj = vec2( sdRoundBox(pos-objPos, node.obejctData[0].xyz, node.obejctData[0].w), 1 );
    }
    else if (node.obejctData[3].w == 2) { // Cone
        node.obejctData[0].y = radians(node.obejctData[0].y);
        objPos.y += node.obejctData[0].x;
        obj = vec2( sdCone(pos-objPos, vec2(sin(node.obejctData[0].y), cos(node.obejctData[0].y)), node.obejctData[0].x), 1 );
    }

    return obj;
}

#define MAX_STACK_SIZE 10

struct Stack {
    int items[MAX_STACK_SIZE];
    int top;
};

vec2 calcGroup(vec3 pos, int nodeId) {
    vec2 objects = vec2(1.0, 0.0);
    vec2 obj;
    NodeData node;
    Stack nodeStack;
    nodeStack.top = 0;

    nodeStack.top = 1;
    nodeStack.items[0] = nodeId;
    while (nodeStack.top > 0) {
        int currentNodeId = nodeStack.items[nodeStack.top-1];
        nodeStack.top = nodeStack.top - 1;

        node = SceneNodes.nodes[currentNodeId];
        int boolOperation = int(node.data1.x);

        if (node.data0.w == 0) { continue; }
        vec2 groupObjects = vec2(1.0, 0.0);

        for (int j = node.data0.z; j < node.data0.z + node.data0.w; ++j) {
            NodeData childNode = SceneNodes.nodes[j];

            if (childNode.data1.y > 0) {
                nodeStack.top = nodeStack.top + 1;
                nodeStack.items[nodeStack.top-1] = j;
            } else {
                obj = calcObj(pos, SceneNodes.nodes[j]);

                if (boolOperation == 0) {
                    groupObjects = opU(groupObjects, obj, 0.1);
                } else if (boolOperation == 1) {
                    groupObjects = opS(groupObjects, obj, 0.1);
                } else if (boolOperation == 2) {
                    groupObjects = opI(groupObjects, obj, 0.1);
                }
            }
        }
        if (currentNodeId > 0) { // not fist node
            boolOperation = int(SceneNodes.nodes[node.data0.y].data1.x);
            if (boolOperation == 0) {
                objects = opU(objects, groupObjects, 0.1);
            } else if (boolOperation == 1) {
                objects = opS(objects, groupObjects, 0.1);
            } else if (boolOperation == 2) {
                objects = opI(objects, groupObjects, 0.1);
            }
        }
        else {
            objects = groupObjects;
        }
    }

    return objects;
}

vec2 map(in vec3 pos) {
    vec2 res = vec2(pos.y, 0.0);
    vec2 objects = vec2(1.0, 0.0);
    NodeData node = SceneNodes.nodes[0];
    int boolOperation = int(node.data1.x);

    if (SceneData.sceneSize <= 1) {
        return res;
    }

    objects = calcGroup(pos, 0);

    res = opU(res, objects, 0.0);

    return res;
}